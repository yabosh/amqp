package amqp

import (
	"fmt"
	"time"

	"github.com/streadway/amqp"
	"github.com/yabosh/go-clock"
	"github.com/yabosh/logger"
	"github.com/yabosh/recovery"
)

// An AMQP consumption client that uses the Observer pattern to return messages
// that are read from a queue.
//
// Each instance of a client supports reading from a single queue that is attached
// to a single exchange with a single binding key.  If the specified exchange
// does not exist, the client attempts to create it.
//
// As messages are read from an AMQP queue they are passed to a function that is
// provided when the consumer is created.

// Consumer is an interface specification that defines the operations that can be performed
// on an AMQP consumer.  The basic consumer consists of a goroutine that actively
// retrieves messages from AMQP and an observer function that is called for every
// message retrieved.
type IConsumer interface {
	// Start instructs the consumer to begin listening for and consuming inforation from AMQP
	Start()

	// SetObserver provides a function that will be called every time the consumer receives a new message
	SetObserver(obs MessageProcessor)
}

// Payload represents the contents of a message retrieved from an AMQP queue.
type Payload struct {
	ContentType     string
	ContentEncoding string
	CorrelationId   string
	Timestamp       time.Time
	AppId           string
	Exchange        string
	RoutingKey      string
	Headers         amqp.Table
	Body            []byte
}

// MessageProcessor is a type of function that is called whenever a
// message is received from an AMQP queue.
type MessageProcessor func(message *Payload) error

// Consumer refers to a connection to an AMQP instance that reads messages.
type Consumer struct {
	LastHeartbeat               time.Time
	handler                     MessageProcessor
	config                      *consumerConfig
	broker                      *BrokerConfig
	source                      string
	conn                        *amqp.Connection
	channel                     *amqp.Channel
	queue                       *amqp.Queue
	messages                    <-chan amqp.Delivery
	connectionCloseNotification chan *amqp.Error
	channelCloseNotification    chan *amqp.Error
	heartbeatTicker             *time.Ticker
	heartbeatExpiration         time.Duration
	url                         string
}

// consumerConfig represents configuration information that is unique to connections that consume from an AMQP queue
type consumerConfig struct {
	exchangeName      string
	exchangeType      string
	queueName         string
	exclusive         bool
	autoDelete        bool
	durable           bool
	queueBindingKeys  []string
	messageConsumer   string
	queueTTL          *int
	lifetime          time.Duration
	connectionTimeout time.Duration
}

const (
	xExpiresHeader = "x-expires"
)

// newMessageConsumerConfig returns a new, initialized instance of ConsumerConfig
func newMessageConsumerConfig(brokerConfig BrokerConfig, exchange string, exchangeType string, queue string, bindingKeys []string) *consumerConfig {
	c := new(consumerConfig)
	c.exchangeName = exchange
	c.exchangeType = exchangeType
	c.queueName = queue
	c.queueBindingKeys = bindingKeys
	c.messageConsumer = brokerConfig.ConsumerName
	c.lifetime, _ = time.ParseDuration("0s") // 0s = infinite
	c.connectionTimeout, _ = time.ParseDuration(brokerConfig.ConnectionTimeout)
	c.exclusive = false
	c.autoDelete = false
	c.durable = true
	c.queueTTL = nil
	return c
}

// NewConsumer creates a new, initialized instance of an AMQP message consumer using
// the configuration information supplied in config.  New incoming AMQP messages
// are sent to the handler function provided.
func NewConsumer(broker BrokerConfig, exchangeType string, queueName string, bindingKeys []string) *Consumer {
	config := newMessageConsumerConfig(
		broker,              // rabbit connection info
		broker.ExchangeName, // exchange name
		exchangeType,        // exchange type
		queueName,           // queue name
		bindingKeys,         // queue binding key
	)

	return &Consumer{
		config: config,
		broker: &broker,
		url:    broker.url(),
	}
}

// SetExclusive marks the queue to be exclusive so that
// only one client at a time can connect.

func (c *Consumer) SetExclusive(value bool) {
	c.config.exclusive = value
}

// SetAutoDelete marks the queue so that RabbitMQ will
// automatically delete the queue when the client disconnects.
func (c *Consumer) SetAutoDelete(value bool) {
	c.config.autoDelete = value
}

// SetDurable marks the queue to determine if the values
// stored in the queue will persist across restarts
func (c *Consumer) SetDurable(value bool) {
	c.config.durable = value
}

// SetQueueTTL sets the time to live for the queue in milliseconds
func (c *Consumer) SetQueueTTL(value int) {
	ttl := value
	c.config.queueTTL = &ttl
}

// SetSource sets a prefix that is appended to any log messages generated by the consumer
func (c *Consumer) SetSource(source string) {
	if c == nil {
		return
	}

	c.source = source
}

// SetObserver provides a function to be called whenever a message is received from AMQP
func (c *Consumer) SetObserver(obs MessageProcessor) {
	if c == nil {
		return
	}

	c.handler = obs
}

// Start connects to a previously defined AMQP queue
// and begins consuming messages. All messages consumed are sent to the
// MessageProcessor provided in NewConsumer
//
// This call blocks until a panic occurs.
func (c *Consumer) Start() {
	c.connectWithRetry()
	c.receiveLoop()
}

func (c *Consumer) recover(msg string) {
	if err := recover(); err != nil {
		logger.Error(msg, err)
	}
}

func (c *Consumer) receiveLoop() {
	// defer c.recover("panicked receiving message from broker:")
	c.heartbeatExpiration = hearbeatInterval
	c.heartbeatTicker = time.NewTicker(c.heartbeatExpiration)
	c.writeHeartbeat()
	defer c.heartbeatTicker.Stop()

	for {
		select {
		case msg := <-c.messages:
			if err := c.handler(c.createPayload(&msg)); err == nil {
				msg.Ack(false)
			} else {
				logger.Error("AMQP Read: %s", err.Error())
			}

		case connErr := <-c.connectionCloseNotification:
			// This is necessary because the amqp library will immediately
			// close this channel after posting any error so this
			// case path will always be taken and cause an infinite loop
			c.connectionCloseNotification = make(chan *amqp.Error)
			c.conn = nil
			c.channel = nil

			if connErr != nil {
				logger.Error("[%s] connection closed %#v", c.source, connErr)
			}

			c.connectWithRetry()

		case reason := <-c.channelCloseNotification:
			logger.Trace("[%s] Channel closed %#v", c.source, reason)
			c.channel = nil
			c.channelCloseNotification = make(chan *amqp.Error)
			if !c.conn.IsClosed() {
				logger.Trace("[%s] Closing connection to message broker", c.source)
				// Closing the channel will force a reconnect which will address some issues such as a missing exchange, etc.
				c.conn.Close()
			}

		case <-c.heartbeatTicker.C:
		}
		c.writeHeartbeat()
	}
}

func (c *Consumer) createPayload(msg *amqp.Delivery) *Payload {
	return &Payload{
		ContentType:     msg.ContentType,
		ContentEncoding: msg.ContentEncoding,
		CorrelationId:   msg.CorrelationId,
		Timestamp:       msg.Timestamp,
		AppId:           msg.AppId,
		Exchange:        msg.Exchange,
		RoutingKey:      msg.RoutingKey,
		Headers:         msg.Headers,
		Body:            msg.Body,
	}
}

// connectWithRetry will continuously try to connect to an AMQP
// host until it succeeds.  An exponential backoff is used
// if the connection fails.
func (c *Consumer) connectWithRetry() {
	var attempt int

	if c.conn != nil && !c.conn.IsClosed() {
		return
	}

	logger.Trace("[%s] Connecting to AMQP message broker", c.source)
	for {
		err := c.connect()
		if err == nil {
			logger.Info("[%s] Connected to AMQP message broker", c.source)
			break
		}

		logger.Error("[%s] failed to connect to message broker: %s", c.source, err)
		attempt++
		recovery.BackoffS(attempt)
	}
}

// connect will establish a connection to an AMQP host
func (c *Consumer) connect() (err error) {
	defer func() {
		if reco := recover(); reco != nil {
			err = fmt.Errorf("[%s] panicked connecting to message broker: %v", c.source, reco)
		}
	}()

	logger.Trace("[%s] Dialing... %s", c.source, c.url)
	c.conn, err = amqp.Dial(c.url)
	if err != nil {
		return fmt.Errorf("[%s] failed to connect to message broker: %s", c.source, err)
	}

	logger.Trace("[%s] Creating channel", c.source)
	c.channel, err = c.conn.Channel()
	if err != nil {
		c.conn.Close()
		return fmt.Errorf("[%s] failed to open a channel: %s", c.source, err)
	}

	logger.Trace("[%s] Setting up notifications", c.source)
	c.connectionCloseNotification = make(chan *amqp.Error)
	c.conn.NotifyClose(c.connectionCloseNotification)

	c.channelCloseNotification = make(chan *amqp.Error)
	c.channel.NotifyClose(c.channelCloseNotification)

	return c.createComponents()
}

// createComponents will do some basic housekeeping before allowing the connection to be used.
func (c *Consumer) createComponents() (err error) {
	err = c.ensureExchangeExists()
	if err != nil {
		c.conn.Close()
		return err
	}

	err = c.ensureQueueBound()
	if err != nil {
		c.conn.Close()
		return err
	}

	err = c.consumeMessages()
	if err != nil {
		c.conn.Close()
		return err
	}

	return err
}

func (c *Consumer) ensureExchangeExists() error {
	logger.Info("[%s] Ensuring that exchange '%s' of type '%s' exists", c.source, c.config.exchangeName, c.config.exchangeType)
	err := ensureExchangeExists(c.channel, c.config.exchangeName, c.config.exchangeType)

	if err != nil {
		return fmt.Errorf("[%s] failed to declare '%s' exchange '%s': %s", c.source, c.config.exchangeType, c.config.exchangeName, err)
	}

	return nil
}

func (c *Consumer) ensureQueueBound() error {
	var args amqp.Table

	if c.config.queueTTL != nil {
		args = make(amqp.Table)
		args[xExpiresHeader] = *c.config.queueTTL
	}

	q, err := c.channel.QueueDeclare(
		c.config.queueName,
		c.config.durable,
		c.config.autoDelete,
		c.config.exclusive,
		false, // no-wait
		args,  // arguments
	)
	if err != nil {
		return fmt.Errorf("[%s] failed to declare queue '%s': %s", c.source, c.config.queueName, err)
	}
	c.queue = &q

	return c.bindKeysToQueue(q.Name, c.config.exchangeName)
}

func (c *Consumer) bindKeysToQueue(name string, exchange string) (err error) {
	// Bind all keys to the queue
	for _, key := range c.config.queueBindingKeys {
		err = c.channel.QueueBind(
			name,
			key,
			exchange,
			false,
			nil,
		)
		if err != nil {
			return fmt.Errorf("[%s] failed to bind queue '%s' to exchange '%s' with key '%#v': %s", c.source, name, exchange, c.config.queueBindingKeys, err)
		}

	}

	return nil
}

func (c *Consumer) consumeMessages() error {
	msgs, err := c.channel.Consume(
		c.config.queueName,       // queue
		c.config.messageConsumer, // consumer
		false,                    // auto-ack
		false,                    // exclusive
		false,                    // no-local
		false,                    // no-wait
		nil,                      // args
	)

	if err != nil {
		return fmt.Errorf("[%s] failed to register a consumer on queue: '%s': %s", c.source, c.config.queueName, err)
	}

	c.messages = msgs

	return nil
}

func (c *Consumer) writeHeartbeat() {
	c.LastHeartbeat = clock.Now()
}
